<assembly xmlns="http://jasperblues.github.com/spring-objective-c/schema/assembly"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://jasperblues.github.com/spring-objective-c/schema/assembly
        http://jasperblues.github.com/spring-objective-c/schema/assembly.xsd">

    <description>
        This is the application assembly. The schema declaration above gives code-completion in supported IDEs
        (works in AppCode, but the Xcode XML editor doesn't resolve schemas, it seems).
        Dependencies can be resolved by reference (ie a name), by matching the required type or protocol or by value.
        Dependencies can be declared in any order - Spring Objective-C will work out how to resolve them.
    </description>

    <component class="Knight" key="knight">
        <property name="quest" ref="quest">
            <description>
                Properties can be injected by reference.
            </description>
        </property>
        <property name="damselsRescued" value="12">
            <description>
                Property arguments can also be injected by value. The container will look up the required class or
                primitive type. You can also register your own converters.
            </description>
        </property>
    </component>


    <component class="CampaignQuest" key="quest" scope="prototype" after-property-injection="questAfterPropertyInjection">
        <description>
            Knight has a dependency on any class conforming to the Quest protocol. In this case it's a
            [CampaignQuest class].

            Note the 'after-property-injection' attribute. This is a custom method that can be called after all
            properties have been injected.
        </description>

        <property name="imageUrl" value="http://www.appsquick.ly/theQuest.jpg">
            <description>
                This is a property of type NSURL. The container will convert the supplied string value
                and inject it for us.

                Besides the primitive types (int, BOOL, etc), a handful of useful object conversion types
                are included. You can also easily register your own additional converters.
            </description>
        </property>
    </component>

    <component class="CavalryMan" key="anotherKnight">
        <description>
            This time, we're using initializer injection. As shown below, you can also mix initializer
            injection with property injection.
        </description>
        <initializer selector="initWithQuest:">
            <argument parameterName="quest" ref="quest"/>
        </initializer>
        <property name="hasHorseWillTravel" value="yes">
            <description>
                Besides object conversion types, primitives are supported. This is a primitive property
                of type BOOL - the container will convert it for us.
            </description>
        </property>
    </component>


    <component class="NSURL" key="serviceUrl">
        <description>
            This is an example of a component instantiated from a class method. (In fact, you could inject
            an NSURL instance directly by value, but anyway. . . ).

            Note the "is-class-method" attribute: Spring Objective-C will normally guess this, so if the method
            follows objective-c naming conventions, this wouldn't be needed.
        </description>
        <initializer selector="URLWithString:" is-class-method="yes">
            <description>
                Initializer arguments require type to be set explicitly, unless the type is a primitive
                (BOOL, int , etc).
            </description>
            <argument parameterName="string" value="http://dev.foobar.com/service/" required-class="NSString"/>
        </initializer>
    </component>

    <component class="NSURL" key="anotherServiceUrl">
        <initializer selector="URLWithString:">
            <argument parameterName="string" value="http://dev.foobar.com/service/">
                <description>
                    This will fail because the required-class attribute is not set.
                </description>
            </argument>
        </initializer>
    </component>


</assembly>
