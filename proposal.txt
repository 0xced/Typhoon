Nice idea! I spent some time on Thursday hacking on 'parameterized definitions'. Both seem like they might solve a similar problem.

For example, consider a class `Moat` with a single property `filledWith`. Say your application uses a moat filled with lava somewhere in the code, and a moat filled with (relatively) harmless water somewhere else. Currently, you need four methods in the assembly returning definitions:

- (id)moatFilledWithLava;
- (id)moatFilledWithWater;
- (id)lava;
- (id)water;

But what if you could do this?

- (id)moatFilledWith:(id)aDangerousLiquid;
- (id)lava;
- (id)water;

You'd still usually want to create the specific definitions for clients to use:

- (id)moatFilledWithLava;
- (id)moatFilledWithWater;

But, these are now deduplicated. Say the moat also requires a bridge, which your application has one definition for:

- (id)bridge;

Previously:

- (id)moatFilledWithWater;
{
    return [TyphoonDefinition withClass:[Moat class] properties:^(TyphoonDefinition *definition) {
        [definition injectProperty:@selector(filledWith) withDefinition:[self water]];
        [definition injectProperty:@selector(bridge)];
    }];
}

- (id)moatFilledWithLava;
{
    return [TyphoonDefinition withClass:[Moat class] properties:^(TyphoonDefinition *definition) {
        [definition injectProperty:@selector(filledWith) withDefinition:[self lava]];
        [definition injectProperty:@selector(bridge)];
    }];
}

The bridge property is duplicated. You can now extract this duplication.

- (id)moatFilledWithWater;
{
  return [self moatFilledWith:[self water]];
}

- (id)moatFilledWithLava;
{
  return [self moatFilledWith:[self lava]];
}

- (id)moatFilledWith:(id)aDangerousLiquid;
{
    return [TyphoonDefinition withClass:[Moat class] properties:^(TyphoonDefinition *definition) {
        [definition injectProperty:@selector(filledWith) withDefinition:aDangerousLiquid];
        [definition injectProperty:@selector(bridge)];
    }];
}

This wasn't the original idea that motivated me, though. What I was looking for was a parameterized provider, which would allow me to pass in an object constructed dynamically into a factory method and get back a constructed instance. Currently, if you need to do this, you just have to failover to constructing objects manually. You lose the viral construction provided by DI, which means that all objects that are dependencies of the object you want to dynamically construct (with a parameter) must also be constructed by hand.

I have an object that takes a core data stack constructed at runtime, and I want to do this:

- (id)refresherOnStack:(id)coreDataStack;
{
    return [TyphoonDefinition withClass:[Refresher class] initialization:^(TyphoonInitializer *initializer) {
        initializer.selector = @selector(initWithConsumer:);
        
        [initializer injectWithDefinition:[self consumerOnStack:coreDataStack]];
    }];
}

- (id)consumerOnStack:(id <RHGCoreDataStack>)coreDataStack;
{
    return [TyphoonDefinition withClass:[Consumer class] initialization:^(TyphoonInitializer *initializer) {
        initializer.selector = @selector(initWithAPIClient:coreDataStack:someStaticDependency:);
        
        [initializer injectWithDefinition:[self apiClient]];
        [initializer injectWithRuntimeObjectOrDefinition:coreDataStack];
        [initializer injectWithDefinition:[self someStaticDependency]];
    }];
}

- (id)someStaticDependency;
{
    return [TyphoonDefinition withClass:[someStaticDependency class]];
}

But I digress. If you had something that depended on a notification center, then you could write:

- (id)notifier
{
    return [TyphoonDefinition withClass:[Notifier class] initialization:^(TyphoonInitializer *initializer) {
        initializer.selector = @selector(initWithNotifier);
        
        [initializer injectWithRuntimeObject:[NSNotificationCenter defaultCenter]];
    }];
}

Better yet:

- (id)notifier
{
    return [TyphoonDefinition withClass:[Notifier class] initialization:^(TyphoonInitializer *initializer) {
        initializer.selector = @selector(initWithNotifier);
        
        [initializer injectWithRuntimeObjectOrDefinition:[self notificationCenter]];
    }];
}

- (id)notificationCenter
{
    return [NSNotificationCenter defaultCenter]; // is this good, though?
}

- (id)notificationCenter
{
    return [TyphoonDefinition withClass:[NSNotificationCenter class] initialization:^(TyphoonInitializer *initializer) {
        initializer.selector = @selector(defaultCenter);
    }];
}
